from openai import OpenAI
from flask import Flask, render_template, request, jsonify, session
from dotenv import load_dotenv
from datetime import datetime
import os
import random
import re
import zlib
import base64
import smtplib
import tempfile
from email.mime.text import MIMEText
from flask_session import Session

load_dotenv()

app = Flask(__name__)
app.secret_key = os.getenv("FLASK_SECRET_KEY", os.urandom(24))

app.config['SESSION_TYPE'] = 'filesystem'
app.config['SESSION_PERMANENT'] = False
app.config['SESSION_USE_SIGNER'] = True
app.config['SESSION_FILE_DIR'] = '/tmp/flask_session'
app.config['SESSION_FILE_THRESHOLD'] = 100

Session(app)

client = OpenAI()

MODEL_ENGINE = "gpt-3.5-turbo"

SITUATIONS = [
    {
        "id": 1,
        "description": "шуруповерт",
        "requirements": "потрібен на дачу для дрібного ремонту: прикрутити полицю, повісити замок тощо",
        "avatar": "id1.png",
        "behavior": "дружелюбний, не дуже розбирається в техніці",
        "correct_models": ["CD-12QX", "CD-12CX"],
        "wrong_models": ["CD-200BCULTRA", "CD-201HBC", "CD-200BCCOMPACT"],
        "hints": [
        "Потрібен для періодичного ремонту на дачі",
        "Максимум — прикрутити полицю або замінити петлю",
        "Хочу щось просте, без складних функцій",
        "Роботи мало, але інструмент має бути під рукою",
        "Щоб не був важкий і складний у користуванні"
        ]
    },
    {
        "id": 2,
        "description": "шуруповерт",
        "requirements": "для постійної збірки меблів у клієнтів",
        "avatar": "id2.png",
        "behavior": "впевнено ставить питання",
        "correct_models": ["CD-218Q", "CD-200BCCOMPACT"],
        "wrong_models": ["CD-12QX", "CD-12CX"],
        "hints": [
        "Щодня збираю меблі у квартирах",
        "Потрібен швидкий доступ до зміни біти",
        "Часто працюю з металевими профілями",
        "Необхідна витривалість, працюю багато",
        "Зручно, коли шуруповерт легкий, але потужний"
        ]
    },
    {
        "id": 3,
        "description": "шуруповерт",
        "requirements": "компактний, простий у використанні шуруповерт для базових робіт",
        "avatar": "id9.png",
        "behavior": "спокійно відповідає",
        "correct_models": ["CD-12QX", "CD-12CX", "CD-12BC"],
        "wrong_models": ["CD-200BCULTRA", "CD-201HBC", "CD-218Q", "CD-200BCCOMPACT"],
        "hints": [
        "Шукаю 12V шуруповерт як подарунок",
        "Батько іноді щось підкручує вдома або в гаражі",
        "Йому потрібен простий та надійний інструмент",
        "Без складних налаштувань",
        "Головне — щоб був легкий і зрозумілий"
        ]
    },
    {
        "id": 4,
        "description": "шуруповерт",
        "requirements": "для монтажу гіпсокартону на об'єктах",
        "avatar": "id4.png",
        "behavior": "коротко формулює потребу",
        "correct_models": ["CD-218Q", "CD-200BCCOMPACT"],
        "wrong_models": ["CD-12CX", "CD-12QX", "CD-12BC"],
        "hints": [
        "Працюю монтажником, займаюся перегородками",
        "Важлива зручність і швидкість заміни біти",
        "Робота з гіпсокартоном — постійно",
        "Треба щось витривале, бо об'єми великі",
        "12V вже пробував — замало"
        ]
    },
    {
        "id": 5,
        "description": "шуруповерт",
        "requirements": "інструмент для свердління дерева і металу при столярних роботах",
        "avatar": "id5.png",
        "behavior": "технічно підкований",
        "correct_models": ["CD-200BCULTRA", "CD-12BC", "CD-200BCCOMPACT"],
        "wrong_models": ["CD-12QX", "CD-218Q"],
        "hints": [
        "Свердлю дерево спіральними свердлами",
        "Іноді — метал до 10 мм",
        "Потрібна стабільна потужність",
        "Використовую тримачі, струбцини, бури",
        "12V слабкуватий, треба щось продуктивне"
        ]
    },
    {
        "id": 6,
        "description": "шуруповерт",
        "requirements": "для дрібного ремонту сантехніки та меблів у квартирі",
        "avatar": "id6.png",
        "behavior": "спокійно слухає і уточнює",
        "correct_models": ["CD-12QX", "CD-12CX"],
        "wrong_models": ["CD-200BCULTRA", "CD-201HBC"],
        "hints": [
        "Час від часу відкручую сифон або петлі в шафах",
        "Іноді потрібно просвердлити ДСП",
        "Хочу невеликий, зручний шуруповерт",
        "Маю невеликі руки — важливо, щоб зручно лежав",
        "Важливо, щоб не треба було часто заряджати"
        ]
    },
    {
        "id": 7,
        "description": "шуруповерт",
        "requirements": "для свердління отворів у плитці, бетоні, дереві — майстер універсал",
        "avatar": "id7.png",
        "behavior": "вимогливий, знає, що шукає",
        "correct_models": ["CD-201HBC", "CD-200BCULTRA"],
        "wrong_models": ["CD-12CX", "CD-218Q", "CD-12QX"],
        "hints": [
        "Потрібен ударний режим — працюю з бетоном",
        "Іноді треба пройти плитку, а далі дерево",
        "Постійна робота на ремонтах",
        "Потрібна надійність і витривалість",
        "Звик працювати з якісним інструментом"
        ]
    },
    {
        "id": 8,
        "description": "шуруповерт",
        "requirements": "для хобі – моделювання меблів із фанери",
        "avatar": "id8.png",
        "behavior": "ентузіаст, емоційно описує процес",
        "correct_models": ["CD-12BC", "CD-12QX"],
        "wrong_models": ["CD-201HBC", "CD-200BCULTRA"],
        "hints": [
        "Роблю шафки, полички з фанери",
        "Потрібна точність і контроль обертів",
        "Іноді працюю по кілька годин підряд",
        "Не хочеться, щоб патрон розхитувався",
        "Дизайн інструменту теж має значення"
        ]
    },
    {
        "id": 9,
        "description": "шуруповерт",
        "requirements": "для будівельної бригади, багато свердління, бетон",
        "avatar": "id10.png",
        "behavior": "дуже конкретний і практичний",
        "correct_models": ["CD-201HBC", "CD-200BCULTRA"],
        "wrong_models": ["CD-12CX", "CD-12QX", "CD-218Q"],
        "hints": [
        "Шуруповерт буде в руках 5 різних людей щодня",
        "Треба, щоб тягнув бетон і цеглу",
        "Працюємо з дюбелями, анкерами",
        "12V навіть не пропонуйте",
        "Потрібна витривалість і ресурс"
        ]
    },
    {
        "id": 10,
        "description": "шуруповерт",
        "requirements": "інструмент для молодого майстра – універсальний і сучасний",
        "avatar": "id11.png",
        "behavior": "відкритий, але вагається",
        "correct_models": ["CD-200BCCOMPACT", "CD-12BC"],
        "wrong_models": ["CD-12CX", "CD-200BCULTRA"],
        "hints": [
        "Тільки починаю працювати на ремонтах",
        "Хочу універсальний інструмент, щоб під все підійшов",
        "Бажано щось сучасне і компактне",
        "Поки не знаю, з чим частіше працюватиму",
        "Шукаю щось, що не перегріється одразу"
        ]
    },
    {
        "id": 11,
        "description": "болгарка.",
        "requirements": "мережева болгарка, висока потужність і зручність у роботі",
        "avatar": "id6.png",
        "behavior": "переважно спокійний, іноді схильний до експериментів",
        "correct_models": ["GS-140SE", "GL-160SE", "GL-145S"],
        "wrong_models": ["GS-98", "GS-100S", "CG-12BC", "GL-125S", "DGA-201"],
        "hints": [
        "Мені точно потрібна мережева болгарка для шліфування металу",
        "для різання, шліфування та зачистки"
        "Працюю з металом та шліфую великі поверхні",
        "Важлива висока потужність, продуктивність і надійність",
        "Треба болгарка на 125 мм діаметр диску",
        "Хочу надійно контролювати інструмент"
        ]
    },
    {
        "id": 12,
        "description": "болгарка для різки.",
        "requirements": "маленька мережева болгарка, зручна рукоятка, регулювання обертів",
        "avatar": "id7.png",
        "behavior": "акуратний у роботі, але іноді потребує високої продуктивності",
        "correct_models": ["GS-98", "GS-100S"],
        "wrong_models": ["CG-12BC", "DGA-201", "GS-140SE", "GL-160SE", "GL-125S"],
        "hints": [
            "Потрібен інструмент для чистової обробки металу",
            "для арматури та металу",
            "Важливо, щоб болгарка була компактна та зручна",
            "Працюю з тонким металом, тому потужність може бути невеликою",
            "Потрібна коротка ручка",
            "Диск 125 мм – ідеальний розмір для моїх задач"
        ]
    },
    {
        "id": 13,
        "description": "болгарка з регулятором.",
        "requirements": "надійна, потужна, з підтримкою обертів",
        "avatar": "id10.png",
        "behavior": "інтенсивне використання, але з дотриманням техніки безпеки",
        "correct_models": ["GS-140SE"],
        "wrong_models": ["GS-98", "GS-100S", "CG-12BC", "GL-125S", "DGA-201", "GL-160SE", "GL-240"],
        "hints": [
            "Часто ріжу арматуру, потрібна стійкість до навантажень",
            "Для ремонту, доволі тривалого",
            "Потрібна модель мережева з великою потужністю",
            "Важливо, щоб не перегрівалася при тривалій роботі",
            "125 мм діаметр диску - мені підходить",
            "Розглядаю моделі із короткою ручкою"
        ]
    },
    {
        "id": 14,
        "description": "проста болгарка додому",
        "requirements": "здатна виконувати прості завдання без жодних проблем",
        "avatar": "id1.png",
        "behavior": "дідусь",
        "correct_models": ["GS-98", "GS-100S", "GL-125S"],
        "wrong_models": ["CG-12BC", "DGA-201", "GS-140SE", "GL-160SE"],
        "hints": [
            "Шліфую зварні шви, ріжу арматуру в гаражі",
            "Треба недорога модель",
            "Краще з довгою ручкою, бо руки вже трохи не тримають",
            "125 мм діаметр диску ідеально підійде"
        ]
    },
    {
        "id": 15,
        "description": "акумуляторна болгарка.",
        "requirements": "маленька акумуляторна болгарка для вузькоспеціалізованих завдань",
        "avatar": "id2.png",
        "behavior": "експерт з автомобілів",
        "correct_models": ["DGA-201", "CG-12BC"],
        "wrong_models": ["GS-98", "GS-100S", "GL-125S", "GS-140SE", "GL-160SE"],
        "hints": [
            "Потрібен інструмент максимально зручний та компактний",
            "Важлива мобільність для мене і зручність",
            "працюю під машиною, важлива мобільність",
            "потрібен інструмент із короткою ручкою",
            "працюю лише з металом товщинами до 4 мм"
        ]
    },
    {
        "id": 16,
        "description": "легкий перфоратор.",
        "requirements": "компактний та недорогий перфоратор для роботи по дому",
        "avatar": "id5.png",
        "behavior": "красивий клієнт",
        "correct_models": ["DHR-200", "DHR-202BC"],
        "wrong_models": ["BH-30", "BH-20", "RH-16"],
        "hints": [
            "Шукаю перфоратор для нечастого домашнього використання",
            ""
            "Потрібно іноді просверлити отвір у стіні",
            "Важливо, щоб був легкий і не займав багато місця",
            "Не потрібен потужний професійний інструмент",
            "Бюджет до 3000 грн"
        ]
    },
    {
        "id": 17,
        "description": "перфоратор для дрібного ремонту.",
        "requirements": "акумуляторний перфоратор з режимом удару",
        "avatar": "id4.png",
        "behavior": "заляканий клієнт",
        "correct_models": ["DHR-201BC"],
        "wrong_models": ["RH-100", "BH-14S", "BH-30", "RH-12Q", "RH-16"],
        "hints": [
            "Потрібен перфоратор для дрібних ремонтних робіт",
            "Важливо мати режим руйнування для демонтажних робіт",
            "Шукаю безщітковий двигун для довговічності",
            "Потрібна балансована потужність",
            "Бюджет до 4000 грн"
        ]
    },
    {
        "id": 18,
        "description": "перфоратор.",
        "requirements": "потужний та зручний перфоратор для частого використання",
        "avatar": "id12.png",
        "behavior": "клієнт-задрот",
        "correct_models": ["DHR-202BC", "DHR-201BC"],
        "wrong_models": ["DHR-200", "RH-100", "BH-30", "RH-12Q", "RH-16"],
        "hints": [
            "Шукаю перфоратор для регулярних ремонтних робіт",
            "Важлива антивібраційна система для комфортної роботи",
            "Потрібна більша ударна сила ніж у базових моделей",
            "Бочкова конструкція для кращого балансу",
            "Готовий заплатити за якість"
        ]
    },
    {
        "id": 19,
        "description": "бюджетний перфоратор",
        "requirements": "недорогий та надійний прямий перфоратор",
        "avatar": "id13.png",
        "behavior": "смішний клієнт",
        "correct_models": ["RH-100", "RH-12Q"],
        "wrong_models": ["DHR-202BC", "BH-20", "BH-30", "DHR-200", "BH-14S"],
        "hints": [
            "Потрібен простий і надійний перфоратор",
            "Важливо мати хорошу ударну силу за доступну ціну",
            "Кейс у комплекті - великий плюс",
            "Не потрібні додаткові функції",
            "Бюджет до 4500 грн"
        ]
    },
    {
        "id": 20,
        "description": "перфоратор.",
        "requirements": "перфоратор з додатковими можливостями для різних задач",
        "avatar": "id14.png",
        "behavior": "клієнт-слюсар",
        "correct_models": ["RH-12Q"],
        "wrong_models": ["RH-100", "DHR-200", "BH-14S", "BH-30", "RH-16"],
        "hints": [
            "Шукаю перфоратор, який може і сверлити, і працювати як перфоратор",
            "Додатковий патрон для свердел - важлива функція",
            "Потрібна гарна ударна сила",
            "Хочу щоб йшов у кейсі",
            "Готовий заплатити за додаткові можливості"
        ]
    },
    {
        "id": 21,
        "description": "професійний перфоратор.",
        "requirements": "найпотужніший прямий перфоратор для складних задач",
        "avatar": "id15.png",
        "behavior": "веселий",
        "correct_models": ["RH-16"],
        "wrong_models": ["DHR-200", "RH-100", "DHR-201BC", "BH-14S", "RH-12Q"],
        "hints": [
            "Потрібен найпотужніший прямий перфоратор",
            "Виконую професійні ремонтні роботи",
            "Важлива максимальна ударна сила",
            "Кейс у комплекті - обов'язково",
            "Ціна не головний критерій"
        ]
    },
    {
        "id": 22,
        "description": "перфоратор.",
        "requirements": "балансований перфоратор для різних видів робіт",
        "avatar": "id10.png",
        "behavior": "людина-настрій",
        "correct_models": ["BH-14S", "BH-20"],
        "wrong_models": ["DHR-200", "RH-100", "BH-30", "RH-100"],
        "hints": [
            "Шукаю універсальний перфоратор для різних задач",
            "Важлива антивібраційна система",
            "Потрібен окремий регулятор обертів",
            "Бочкова конструкція для зручності",
            "Готовий заплатити за якість"
        ]
    },
    {
        "id": 23,
        "description": "перфоратор.",
        "requirements": "перфоратор для інтенсивного професійного використання",
        "avatar": "id1.png",
        "behavior": "клієнт-професіонал",
        "correct_models": ["BH-20", "BH-30"],
        "wrong_models": ["DHR-200", "RH-100", "DHR-201BC", "RH-16"],
        "hints": [
            "Потрібен професійний інструмент для важких робіт",
            "Важливі додаткові функції як індикація зносу",
            "Потрібна висока ударна сила",
            "Виконую роботи щодня",
            "Ціна виправдана якістю"
        ]
    },
    {
        "id": 24,
        "description": "перфоратор.",
        "requirements": "перфоратор для найскладніших професійних задач",
        "avatar": "id2.png",
        "behavior": "клієнт-комунальник",
        "correct_models": ["BH-30"],
        "wrong_models": ["DHR-200", "RH-100", "DHR-201BC"],
        "hints": [
            "Потрібен найпотужніший перфоратор на ринку",
            "Виконую спеціальні професійні завдання",
            "Важливий патрон SDSMAX для важких навантажень",
            "Потрібна максимальна ударна сила",
            "Ціна не головне - потрібна продуктивність"
        ]
    },
    {
        "id": 25,
        "description": "інвертор.",
        "requirements": "малий та легкий зварювальний апарат для періодичного використання",
        "avatar": "id11.png",
        "behavior": "клієнт-ремонтник",
        "correct_models": ["SAB-14DMINI"],
        "wrong_models": ["SAB-15DX", "M-16PW", "SAB-17DX", "M-20D"],
        "hints": [
            "Потрібен найменший інвертор для роботи в обмежених просторах",
            "Важливо, щоб була функція HOT START для легкого підпалу електрода",
            "Працюю з електродами до 4 мм",
            "Не потрібні додаткові функції, головне — компактність",
            "Потрібен недорогий варіант для нерегулярного використання"
        ]
    },
    {
        "id": 26,
        "description": "інвертор.",
        "requirements": "апарат з TIG-LIFT та зручним функціоналом",
        "avatar": "id16.png",
        "behavior": "клієнт-майстер на виробництві",
        "correct_models": ["SAB-15DX", "SAB-17DX"],
        "wrong_models": ["SAB-14DMINI", "M-18D", "M-20D", "M-16PW"],
        "hints": [
            "Потрібен інвертор із режимом TIG-LIFT для аргонного зварювання",
            "Важливі всі базові функції для комфортної роботи",
            "Працюю з різними типами металів",
            "Не потрібна максимальна потужність, головне — універсальність",
            "В комплекті повинні бути кабелі"
        ]
    },
    {
        "id": 27,
        "description": "інвертор.",
        "requirements": "апарат, який працює від 140 В і має хороший захист",
        "avatar": "id17.png",
        "behavior": "клієнт-електрик у сільській місцевості",
        "correct_models": ["M-16PW"],
        "wrong_models": ["SAB-14DMINI", "SAB-17DX", "M-18D", "M-20D"],
        "hints": [
            "Часто працюю там, де нестабільна напруга (низька або коливається)",
            "Потрібен яскравий дисплей для роботи на сонці",
            "Важлива захищеність від перегріву та перевантажень",
            "Працюю електродами до 4 мм",
            "Не потрібні складні функції, головне — стабільність"
        ]
    },
    {
        "id": 28,
        "description": "інвертор.",
        "requirements": "апарат для тривалої роботи з товстими металами",
        "avatar": "id18.png",
        "behavior": "клієнт-зварник на будівництві",
        "correct_models": ["SAB-17DX", "M-18D", "M-20D"],
        "wrong_models": ["SAB-14DMINI", "M-16PW", "SAB-15DX"],
        "hints": [
            "Потрібно варити електродами до 5 мм",
            "Важливий режим TIG-LIFT для якісного аргонного зварювання",
            "Працюю з товстими металами (5+ мм)",
            "Потрібна надійність при тривалому використанні",
            "Готовий платити за професійний інструмент"
        ]
    },
    {
        "id": 29,
        "description": "інвертор.",
        "requirements": "надійний апарат без зайвих функцій",
        "avatar": "id19.png",
        "behavior": "клієнт-бригадир будівельної компанії",
        "correct_models": ["M-18D"],
        "wrong_models": ["SAB-15DX", "M-20D", "SAB-17DX", "M-16PW"],
        "hints": [
            "Потрібна гарантія 5+ років",
            "Працюю переважно електродами до 5 мм",
            "Не потрібні TIG-LIFT та VRD",
            "Шукаю баланс між ціною та надійністю",
            "Інструмент повинен витримувати щоденне навантаження"
        ]
    },
    {
        "id": 30,
        "description": "інвертор.",
        "requirements": "апарат для зварювання товстих конструкцій (10+ мм)",
        "avatar": "id20.png",
        "behavior": "клієнт-інженер на металургійному підприємстві",
        "correct_models": ["M-20D", "M-18D"],
        "wrong_models": ["SAB-14DMINI", "M-16PW", "M-18D"],
        "hints": [
            "Потрібно варити метали товщиною понад 10 мм",
            "Важливий широкий дисплей для точних налаштувань",
            "Потрібна максимальна потужність",
            "Готовий платити за професійне обладнання",
            "В комплекті повинні бути кабелі"
        ]
    },
    {
        "id": 31,
        "description": "ланцюгова пила",
        "requirements": "легка, компактна, для періодичних робіт у саду",
        "avatar": "id25.png",
        "behavior": "власник дачі або приватного будинку",
        "correct_models": ["CS-12", "DSE-15T"],
        "wrong_models": ["NSG-52H", "DSE-24DS", "NSG-65H"],
        "hints": [
        "Гілки інколи заважають проходу — треба щось для обрізки",
        "Максимальний діаметр — 15 см, не більше",
        "Не хочу важкий інструмент — працюватиме дружина",
        "Бензин точно не варіант — тільки щось просте й чисте",
        "Буде лежати в сараї, використання максимум 1 раз на місяць"
        ]
    },
    {
        "id": 32,
        "description": "ланцюгова пила",
        "requirements": "максимальна потужність, для валки дерев",
        "avatar": "id26.png",
        "behavior": "фермер або лісник",
        "correct_models": ["NSG-65H", "NSG-65H"],
        "wrong_models": ["CS-12", "DSE-15T", "DSE-22S"],
        "hints": [
        "Є кілька старих дерев — треба валити повністю",
        "Стовбури товсті, до 50 см",
        "Працювати треба автономно, без проводів",
        "Маю досвід — мені важливо, щоб “не здохла” на середині різу",
        "Шина має бути довга — інакше кожен рез буде мукою"
        ]
    },
    {
        "id": 33,
        "description": "ланцюгова пила",
        "requirements": "середній клас, для дров на зиму",
        "avatar": "id27.png",
        "behavior": "мешканець села або приватного будинку",
        "correct_models": ["NSG-45H", "NSG-45H"],
        "wrong_models": ["CS-12", "DSE-15T", "DSE-24DS"],
        "hints": [
        "Кожну осінь пиляю пару складометрів дров для печі",
        "Стовбури — до 30 см, максимум",
        "Хочу бензинову, щоб не залежати від світла",
        "Не хочу мучитись із запуском — хай заводиться легко",
        "Надійність понад усе — аби на кілька років хватило"
        ]
    },
    {
        "id": 34,
        "description": "ланцюгова пила",
        "requirements": "доступна за ціною, проста в обслуговуванні",
        "avatar": "id28.png",
        "behavior": "непрофесійний користувач",
        "correct_models": ["DSE-22S", "DSE-15T"],
        "wrong_models": ["NSG-65H", "NSG-52H", "CS-12"],
        "hints": [
        "Треба щось універсальне: і гілки зрізати, і дошки перепиляти",
        "До 25 см діаметр — більше не треба",
        "Бажано без крутого сервісу — сам розберусь",
        "Пилитиму нечасто, пару разів на сезон",
        "Не хочу переплачувати за 'навороти', яких не використаю"
        ]
    },
    {
        "id": 35,
        "description": "ланцюгова пила",
        "requirements": "компактна, зручна, для висотних робіт",
        "avatar": "id29.png",
        "behavior": "садівник або працівник ЖКГ",
        "correct_models": ["CS-12", "DSE-15T"],
        "wrong_models": ["NSG-52H", "NSG-45H", "DSE-24DS"],
        "hints": [
        "Обрізаю дерева з драбини — має бути легка",
        "Гілки не товсті — до 20 см максимум",
        "Інструмент має бути маневрений",
        "Не маю часу розбиратись із бензином",
        "Має бути простий запуск і зупинка"
        ]
    },
    {
        "id": 36,
        "description": "ланцюгова пила",
        "requirements": "дешева бензопила для нечастого використання",
        "avatar": "id30.png",
        "behavior": "пенсіонер або сільський господар",
        "correct_models": ["DSG-25H", "NSG-45H"],
        "wrong_models": ["DSE-24DS", "DSE-22S", "CS-12"],
        "hints": [
        "Пиляю раз на кілька місяців, коли треба дрова",
        "Більше 25–30 см дерева не буде",
        "Бензинка краще — електрику вимикають",
        "Головне — щоб не надто важка",
        "Має бути проста, без 'наворотів'"
        ]
    },
    {
        "id": 37,
        "description": "ланцюгова пила",
        "requirements": "інструмент для роботи в приміщенні, точне різання",
        "avatar": "id31.png",
        "behavior": "будівельник або столяр",
        "correct_models": ["DSE-24DS", "DSE-22S"],
        "wrong_models": ["NSG-65H", "NSG-65H", "CS-12"],
        "hints": [
        "Потрібна для порізки балок та бруса в майстерні",
        "Ріжемо заготовки до 35 см діаметру",
        "Бензинові не підходять — задимленість і шум",
        "Потрібна точність, щоб різ не водив",
        "Обов’язково плавний пуск — без ривків"
        ]
    },
    {
        "id": 38,
        "description": "ланцюгова пила",
        "requirements": "інструмент для демонтажних робіт та виїздів",
        "avatar": "id32.png",
        "behavior": "монтажна бригада або підрядник",
        "correct_models": ["NSG-52H", "NSG-52H"],
        "wrong_models": ["DSE-15T", "CS-12", "DSE-22S"],
        "hints": [
        "Зрізаємо балки, старі крокви, іноді пеньки",
        "До 35–40 см діаметру — треба запас по потужності",
        "Має бути витривала — працюємо по 5–6 годин щодня",
        "Потрібна універсальність — і на виїзд, і в полі",
        "Перевага бензину — не залежимо від генератора"
        ]
    },
    {
        "id": 39,
        "description": "ланцюгова пила",
        "requirements": "надійний інструмент для сезонної заготівлі дров",
        "avatar": "id33.png",
        "behavior": "власник приватного будинку з пічним опаленням",
        "correct_models": ["NSG-45H", "NSG-52H"],
        "wrong_models": ["CS-12", "DSE-15T", "DSE-22S"],
        "hints": [
        "Щороку восени ріжу дрова на зиму для хати",
        "Стовбури — по 30–40 см, інколи більше",
        "Має бути бензинова, бо місце віддалене від мережі",
        "Не хочу економити на потужності — хай бере все зразу",
        "Важливо, щоб інструмент витримував кілька годин роботи підряд"
        ]
    },
    {
        "id": 40,
        "description": "ланцюгова пила",
        "requirements": "мінімальна вага і простота — для літньої жінки",
        "avatar": "id34.png",
        "behavior": "пенсіонерка, яка сама доглядає сад",
        "correct_models": ["CS-12", "DSE-15T"],
        "wrong_models": ["NSG-45H", "DSE-24DS", "NSG-52H"],
        "hints": [
        "Треба обрізати гілки в саду — нічого великого",
        "До 15 см максимум — і то не часто",
        "Інструмент має бути легкий, щоб можна було тримати довго",
        "Не розуміюсь на бензині — має бути проста електрична або акум.",
        "Шукаю щось безпечне, з блокуванням ввімкнення"
        ]
    },
    {
        "id": 41,
        "description": "ланцюгова пила",
        "requirements": "інструмент для навчального закладу, безпечний і простий",
        "avatar": "id35.png",
        "behavior": "представник школи чи ліцею",
        "correct_models": ["DSE-22S", "DSE-15T"],
        "wrong_models": ["NSG-65H", "NSG-52H", "CS-12"],
        "hints": [
        "Пила буде у користуванні працівників шкільного господарства",
        "Максимум зрізати гілки і підготувати трохи дров — до 25 см дерева",
        "Має бути проста в обслуговуванні, без складних систем",
        "Безпечна — щоб не було ризиків при включенні",
        "Працює раз у тиждень або рідше, всередині двору"
        ]
    },
    {
        "id": 42,
        "description": "ланцюгова пила",
        "requirements": "для клієнта, який ніколи не працював пилою",
        "avatar": "id36.png",
        "behavior": "новачок, купує перший інструмент",
        "correct_models": ["DSE-15T", "CS-12"],
        "wrong_models": ["NSG-65H", "NSG-52H", "DSE-24DS"],
        "hints": [
        "Хочу просто спробувати попиляти щось у дворі",
        "Переважно гілки до 15–20 см максимум",
        "Боюсь бензопил — хочу щось просте, без шуму",
        "Ідеально — якщо легка і не рве з рук при старті",
        "Не хочу витрачати багато — просто для досвіду"
        ]
    },
    {
        "id": 43,
        "description": "ланцюгова пила",
        "requirements": "професійний інструмент на будівництво",
        "avatar": "id25.png",
        "behavior": "будівельна фірма",
        "correct_models": ["DSE-24DS", "NSG-52H"],
        "wrong_models": ["DSE-15T", "CS-12", "NSG-45H"],
        "hints": [
        "Завдання — пилити балки, дошки, колоди до 35 см",
        "Має витримувати щоденну роботу по 6 годин",
        "Необхідний плавний запуск і антивібрація",
        "Шукаємо баланс між бензиновою потужністю та електричним комфортом",
        "Працюємо у приміщеннях і на відкритому повітрі"
        ]
    },
    {
        "id": 44,
        "description": "ланцюгова пила",
        "requirements": "максимальна продуктивність у польових умовах",
        "avatar": "id26.png",
        "behavior": "лісозаготівельник або господар великої ділянки",
        "correct_models": ["NSG-65H", "NSG-52H"],
        "wrong_models": ["DSE-15T", "DSE-22S", "CS-12"],
        "hints": [
        "Використовую пилу в полі — там де немає електроенергії",
        "Ріжу дерева діаметром до 50 см",
        "Маю досвід, хочу бензинову, яка тягне й не гріється",
        "Працюю у важких умовах — потрібна потужність і надійність",
        "Паливо завжди з собою — важливо, щоб бак був не маленький"
        ]
    },
    {
        "id": 45,
        "description": "ланцюгова пила",
        "requirements": "для дому — іноді різати дерево, зробити лавку чи обрізати яблуню",
        "avatar": "id27.png",
        "behavior": "домовласник із невеликим садом",
        "correct_models": ["DSE-22S", "CS-12"],
        "wrong_models": ["NSG-52H", "NSG-65H", "DSE-24DS"],
        "hints": [
        "Час від часу треба щось підпиляти вдома",
        "Дерева — максимум 25 см, частіше гілки до 15 см",
        "Бензин не хочу — це для мене зайве",
        "Електрична або акумуляторна, аби працювала без мороки",
        "Бажано, щоб не дуже важка — іноді працює дружина"
        ]
    },
    {
        "id": 46,
        "description": "ланцюгова пила",
        "requirements": "інструмент для сервісної компанії, потрібна універсальність",
        "avatar": "id28.png",
        "behavior": "технічна команда або монтажники",
        "correct_models": ["NSG-52H", "DSE-24DS"],
        "wrong_models": ["CS-12", "DSE-15T", "NSG-45H"],
        "hints": [
        "Потрібно і пилити дошки, і різати товсті гілки",
        "Об’єкти різні — має працювати і від мережі, і в полі",
        "Потрібна витривалість — 3–4 об’єкти на тиждень",
        "Один інструмент на кількох людей — важлива зручність",
        "Підходить і для дров, і для монтажу"
        ]
    },
    {
        "id": 47,
        "description": "тример",
        "requirements": "для шкільної території — не важкий і довговічний",
        "avatar": "id29.png",
        "behavior": "представник навчального закладу",
        "correct_models": ["DTC-200BCDUAL", "DNIPRO-M-150S"],
        "wrong_models": ["30L", "33M"],
        "hints": [
        "Техніка буде працювати кілька років",
        "Нечаста робота, для прибирання території шкільного двору",
        "Не завжди досвідчені користувачі",
        "Має бути проста та зручна",
        "Підходить як для трави, так і для бур’яну",
        "Площа обробки — до 10 соток",
        "Очікую акумуляторну або електричну модель"
        ]
    },
    {
        "id": 48,
        "description": "тример",
        "requirements": "легкий, простий, для підстригання газону біля будинку",
        "avatar": "id30.png",
        "behavior": "пенсіонер або дачник",
        "correct_models": ["30L", "DTC-201"],
        "wrong_models": ["DNIPRO-M-150S", "DNIPRO-M-43", "33M"],
        "hints": [
        "Треба щось легке — руками працювати важко",
        "Площа невелика — десь 2–3 сотки",
        "Користуватимусь сам — не хочу шумного бензину",
        "Не коситиму бур’ян — лише підстригати м’яку траву",
        "Бажано, щоб розбирався для зберігання",
        "Площа обробки — до 2–5 соток",
        "Очікую акумуляторну або електричну модель"
        ]
    },
    {
        "id": 49,
        "description": "тример",
        "requirements": "бюджетна модель для рідкісного використання на дачі",
        "avatar": "id31.png",
        "behavior": "дачник-пенсіонер",
        "correct_models": ["30L", "DTC-201"],
        "wrong_models": ["DNIPRO-M-150S", "DNIPRO-M-43", "33M"],
        "hints": [
        "Кошу максимум 2–3 рази на місяць",
        "Ділянка невелика, до 2 соток",
        "Не хочу нічого гучного або з бензином",
        "Потрібно легке — руки швидко втомлюються",
        "Добре, щоб був захист від випадкового запуску",
        "Площа обробки — до 2–5 соток",
        "Очікую акумуляторну або електричну модель"
        ]
    },
    {
        "id": 50,
        "description": "тример",
        "requirements": "універсальний інструмент для різних завдань на ділянці",
        "avatar": "id32.png",
        "behavior": "власник приватного будинку",
        "correct_models": ["33M", "DNIPRO-M-110"],
        "wrong_models": ["30L", "DTC-201", "DTC-200BCDUAL"],
        "hints": [
        "Кошу і траву, і кущі біля паркану",
        "Площа – до 10 соток",
        "Час від часу використовую висоторіз",
        "Хочу мати 3 інструменти в одному",
        "Бажано, щоб зручно зберігався",
        "Площа обробки — до 10 соток",
        "Очікую електричну модель"
        ]
    },
    {
        "id": 51,
        "description": "тример",
        "requirements": "максимально потужний для боротьби з бур’янами",
        "avatar": "id33.png",
        "behavior": "фермер або аграрій",
        "correct_models": ["DNIPRO-M-150S", "DNIPRO-M-43"],
        "wrong_models": ["30L", "DTC-201", "DNIPRO-M-110"],
        "hints": [
        "Скошую бур’яни та густу траву",
        "Площа – понад 5 соток",
        "Користуюсь щотижня",
        "Потрібна модель з ременем та ножем",
        "Не хочу, щоб інструмент перегрівався",
        "Площа обробки — понад 5 соток",
        "Очікую бензинову модель"
        ]
    },
    {
        "id": 52,
        "description": "тример",
        "requirements": "компактний для роботи між деревами",
        "avatar": "id34.png",
        "behavior": "садівник",
        "correct_models": ["DTC-201", "DNIPRO-M-110"],
        "wrong_models": ["DNIPRO-M-150S", "DNIPRO-M-43", "33M"],
        "hints": [
        "Кошу біля дерев та кущів",
        "Необхідно уникати пошкодження стовбурів",
        "Невелика вага – великий плюс",
        "Працюю у вузьких зонах між грядками",
        "Трава переважно м’яка",
        "Площа обробки — до 2–5 соток",
        "Очікую акумуляторну або електричну модель"
        ]
    },
    {
        "id": 53,
        "description": "тример",
        "requirements": "акумуляторний, для невеликої ділянки біля будинку",
        "avatar": "id35.png",
        "behavior": "молодий домовласник",
        "correct_models": ["DTC-200BCDUAL", "DTC-201"],
        "wrong_models": ["DNIPRO-M-43", "DNIPRO-M-150S", "33M"],
        "hints": [
        "Не хочу тягати подовжувач або працювати з бензином",
        "Ділянка приблизно 4–5 соток",
        "Бажано, щоб не шумів сильно",
        "Потрібно, щоб був захист від перенавантаження",
        "Працюю 1–2 рази на тиждень",
        "Площа обробки — до 2–5 соток",
        "Очікую акумуляторну або електричну модель"
        ]
    },
    {
        "id": 54,
        "description": "тример",
        "requirements": "інструмент для обслуговування прибудинкової території ЖК",
        "avatar": "id36.png",
        "behavior": "працівник обслуговуючої компанії",
        "correct_models": ["DNIPRO-M-43", "33M"],
        "wrong_models": ["30L", "DTC-201", "DNIPRO-M-110"],
        "hints": [
        "Треба працювати по 3–4 години щодня",
        "Різна трава – і низька, і груба",
        "Зручно, якщо інструмент витривалий і з ременем",
        "Бажано, щоб не трясло руки – маю кілька годин косіння",
        "Важлива універсальність і міцність",
        "Площа обробки — понад 5 соток",
        "Очікую бензинову модель"
        ]
    },
    {
        "id": 55,
        "description": "тример",
        "requirements": "потужний тример для складних ділянок",
        "avatar": "id25.png",
        "behavior": "будівельна бригада або агрофірма",
        "correct_models": ["DNIPRO-M-150S", "33M"],
        "wrong_models": ["30L", "DTC-201", "DNIPRO-M-110"],
        "hints": [
        "Працюємо в бур'яні та чагарниках",
        "Є ділянки до 10 соток",
        "Інколи потрібно косити біля стін або заїздів",
        "Бензиновий — не обмежує по кабелю",
        "Хочеться комфортного ременя і антивібрації",
        "Площа обробки — до 10 соток",
        "Очікую бензинову модель"
        ]
    },
    {
        "id": 56,
        "description": "тример",
        "requirements": "тільки для докосу після газонокосарки",
        "avatar": "id26.png",
        "behavior": "власник газонокосарки",
        "correct_models": ["DTC-201", "30L"],
        "wrong_models": ["DNIPRO-M-43", "DNIPRO-M-150S", "33M"],
        "hints": [
        "Газон вже коситься основною технікою",
        "Потрібно пройтись по краях біля клумб",
        "Має бути акуратний, не рве траву",
        "Невелика площа — менше 1 сотки",
        "Важлива легкість і компактність",
        "Площа обробки — до 2–5 соток",
        "Очікую акумуляторну або електричну модель"
        ]
    },
    {
        "id": 57,
        "description": "тример",
        "requirements": "інструмент на зміну електротримеру — потрібна автономність",
        "avatar": "id27.png",
        "behavior": "домовласник без доступу до розетки",
        "correct_models": ["DTC-200BCDUAL", "DNIPRO-M-43"],
        "wrong_models": ["DTC-201", "DNIPRO-M-110", "30L"],
        "hints": [
        "Немає розетки у дворі — шукаю акум або бензин",
        "Треба щось на 4–5 соток",
        "Невеликий рельєф — скошую і біля паркану",
        "Не хочу плутатись з подовжувачами",
        "Щоб не втомлював після 30 хв роботи",
        "Площа обробки — до 2–5 соток",
        "Очікую акумуляторну або бензинову модель"
        ]
    },
    {
        "id": 58,
        "description": "тример",
        "requirements": "інструмент для підрядника — працює з ранку до вечора",
        "avatar": "id28.png",
        "behavior": "газонний підрядник",
        "correct_models": ["DNIPRO-M-43", "DNIPRO-M-150S"],
        "wrong_models": ["30L", "DTC-201", "DNIPRO-M-110"],
        "hints": [
        "Щоденна робота — по кілька годин",
        "Кошу не тільки газон, але й бур’яни",
        "Має бути зручний ремінь і хороша витривалість",
        "Замість кількох дешевих — один витривалий",
        "Критично важлива потужність і антивібрація",
        "Площа обробки — понад 5 соток",
        "Очікую бензинову модель"
        ]
    },
    {
        "id": 59,
        "description": "тример",
        "requirements": "потужна, але тиха модель, бо поруч діти",
        "avatar": "id29.png",
        "behavior": "молоді батьки",
        "correct_models": ["DTC-200BCDUAL", "DNIPRO-M-110"],
        "wrong_models": ["DNIPRO-M-43", "DNIPRO-M-150S", "33M"],
        "hints": [
        "Кошу у дворі біля дому, де бігають діти",
        "Голосний звук – небажаний",
        "Бажано без вихлопу — працюємо у дворі",
        "Зручно, якщо легко носити",
        "Площа до 5 соток",
        "Площа обробки — до 2–5 соток",
        "Очікую акумуляторну або електричну модель"
        ]
    },
    {
        "id": 60,
        "description": "тример",
        "requirements": "компактний і надійний для обслуговування дачі",
        "avatar": "id30.png",
        "behavior": "літній власник дачі",
        "correct_models": ["DTC-201", "DNIPRO-M-110"],
        "wrong_models": ["DNIPRO-M-150S", "DNIPRO-M-43", "33M"],
        "hints": [
        "Площа приблизно 4 сотки",
        "Важливо, щоб не важкий",
        "Працювати буду сам — без помічників",
        "Найкраще — електричний або акумулятор",
        "Косити треба раз на 2–3 тижні",
        "Площа обробки — до 2–5 соток",
        "Очікую акумуляторну або електричну модель"
        ]
    },
    {
        "id": 61,
        "description": "тример",
        "requirements": "професійний інструмент для заміських об’єктів",
        "avatar": "id31.png",
        "behavior": "обслуговуюча фірма",
        "correct_models": ["DNIPRO-M-150S", "33M"],
        "wrong_models": ["30L", "DTC-201", "DNIPRO-M-110"],
        "hints": [
        "Потрібно косити території біля ресторанів, готелів",
        "Декілька годин на день без збоїв",
        "Треба легко транспортувати — їздимо по об’єктах",
        "Підходить і для ножа, і для волосіні",
        "Важлива потужність і професійна якість",
        "Площа обробки — до 10 соток",
        "Очікую бензинову модель"
        ]
    },
    {
        "id": 62,
        "description": "тример",
        "requirements": "вибір для першого інструменту — недорогий і безпечний",
        "avatar": "id32.png",
        "behavior": "новачок",
        "correct_models": ["30L", "DTC-201"],
        "wrong_models": ["DNIPRO-M-150S", "DNIPRO-M-43", "33M"],
        "hints": [
        "Ніколи не мав тримера — хочу почати з простого",
        "Головне — щоб не важкий",
        "Площа — 1,5 сотки максимум",
        "Без ножа — тільки волосінь",
        "Цікавить безпечний запуск",
        "Площа обробки — до 2–5 соток",
        "Очікую акумуляторну або електричну модель"
        ]
    },
    {
        "id": 63,
        "description": "обприскувач",
        "requirements": "компактний, щоб не заважав, до 4 соток",
        "avatar": "id33.png",
        "behavior": "пенсіонерка, займається розсадою",
        "correct_models": ["5-H"],
        "wrong_models": ["16S", "12S"],
        "hints": [
            "Треба для теплиці",
            "Та можна й ручний, і на акумуляторі",
            "Легенький треба",
            "Щоб не тік",
            "Для кущів: малина, полуниця, картопелька"
        ]
    },
    {
        "id": 64,
        "description": "обприскувач",
        "requirements": "великий об’єм, працювати без зупинки кілька годин",
        "avatar": "id34.png",
        "behavior": "фермер із досвідом",
        "correct_models": ["16S"],
        "wrong_models": ["5-H", "12S"],
        "hints": [
            "Обробляю щодня",
            "для фермерського господарства — 9 соток",
            "Має бути витривалий",
            "Не боюсь ваги",
            "Беру під навантаження"
        ]
    }
]

TOOL_MODELS = [
    "CD-12QX",
    "CD-200BCULTRA",
    "CD-201HBC",
    "CD-218Q",
    "CD-200BCCOMPACT",
    "CD-12CX",
    "CD-12BC",
    "GS-140SE",
    "GL-160SE",
    "GS-98",
    "GS-100S",
    "GL-145S",
    "GS-120S",
    "GL-240",
    "CG-12BC",
    "GL-125S",
    "DGA-201",
    "DHR-200",
    "DHR-201BC",
    "DHR-202BC",
    "RH-100",
    "RH-12Q",
    "RH-16",
    "BH-14S",
    "BH-20",
    "BH-30",
    "SAB-14DMINI",
    "SAB-15DX",
    "M-16PW",
    "SAB-17DX",
    "M-18D",
    "M-20D",
    "DSG-25H",
    "NSG-45H",
    "NSG-52H",
    "NSG-62H",
    "DSE-15T",
    "DSE-22S",
    "DSE-24DS",
    "DCS-201BCDUAL",
    "CS-12",
    "DNIPRO-M-43",
    "33M",
    "DNIPRO-M-110",
    "DNIPRO-M-150S",
    "30L",
    "DTC-200BCDUAL",
    "DTC-201",
    "5-H",
    "12S",
    "16S"
]

CATEGORY_SITUATION_IDS = {
    "screwdrivers": list(range(1, 11)),
    "grinders": list(range(11, 16)),
    "hammers": list(range(16, 25)),
    "inverters": list(range(25, 31)),
    "saws": list(range(31, 47)),
    "trimmers": list(range(47, 63)),
    "sprayers": list(range(63, 65)),
    "exam": list(range(1, 65))
}

CATEGORY_OBJECTIONS = {
    "screwdrivers": [
        "Мені здається, це трохи дорогувато.",
        "Я бачив в інтернеті дешевше.",
        "Я чув, що ця модель швидко ламається.",
        "А де виробляють цей інструмент?",
        "А вистачить потужності для монтажу на гіпсокартоні?",
        "Мені здається, ця модель слабенька.",
        "Я чув, акумулятори швидко сідають.",
    ],
    "grinders": [
        "Мені здається, це трохи дорогувато.",
        "Я бачив в інтернеті дешевше.",
        "Я чув, що ця модель швидко ламається.",
        "А де виробляють цей інструмент?",
        "А вона не перегрівається під навантаженням?",
        "Чи витримає постійні роботи?",
        "Чув, редуктор швидко зношується.",
    ],
    "hammers": [
        "Мені здається, це трохи дорогувато.",
        "Я бачив в інтернеті дешевше.",
        "Я чув, що ця модель швидко ламається.",
        "А де виробляють цей інструмент?",
        "А він точно зможе довго працювати з такими бурами?",
        "Мені здається, що він не дуже якісний.",
        "Раніше Ваші перфоратори були краще, ніж зараз.",
    ],
    "inverters": [
        "Мені здається, це трохи дорогувато.",
        "Я бачив в інтернеті дешевше.",
        "Я чув, що ця модель швидко ламається.",
        "А де виробляють цей інструмент?",
        "Цей апарат точно нормально варить такими електродами?",
        "А раптом згорить від перепадів напруги?",
        "Я чув, що китайські інвертори недовговічні.",
    ],
    "saws": [
        "Мені здається, це трохи дорогувато.",
        "Я бачив в інтернеті дешевше.",
        "А чого кажуть, що не можна відпрацьоване масло використовувати для ланцюга?",
        "А де виробляють цей інструмент?",
        "Чи не поведе пилу при навантаженні?",
        "Вона точно нормально ріже?",
        "Казали, що її важко обслуговувати.",
    ],
    "trimmers": [
        "Мені здається, це трохи дорогувато.",
        "Я бачив в інтернеті дешевше.",
        "Я чув, що ця модель швидко ламається.",
        "А де виробляють цей інструмент?",
        "А він не заплутається в траві?",
        "Друг розказував, що ваші тримери їдять дуже багато бензину.",
        "А як він працює з сирою травою?",
    ],
    "sprayers": [
        "Мені здається, це трохи дорогувато.",
        "Я бачив в інтернеті дешевше.",
        "Я чув, що ця модель швидко ламається.",
        "А де виробляють цей інструмент?",
        "Цей обприскувач точно якісний?",
        "Чи вистачить тиску для дерев?",
        "Що робити, якщо поламається?",
    ],
    "default": [
        "Мені здається, це трохи дорогувато.",
        "Я бачив в інтернеті дешевше.",
        "Я чув, що ця модель швидко ламається.",
        "А де виробляють цей інструмент?",
    ]
}

FEMALE_VOICES = ["nova", "shimmer", "fable", "verse", "coral"]
MALE_VOICES = ["alloy", "ash", "ballad", "echo", "onyx", "sage"]

FEMALE_IDS = {3, 8, 20, 34, 35, 46, 47, 49, 58, 59, 61}

def is_question(message):
    return "?" in message or message.strip().lower().startswith((
        "прац", "як", "чому", "чи", "який", "яка", "яке", "роб",
        "завдан", "акумулятор", "діамет", "метал", "задач", "мережев",
        "дерево", "матер", "насадки", "режим", "крутний", "момент",
        "потужн", "буд", "свер"
    ))

def send_email_report(subject, body, to_email):
    msg = MIMEText(body, 'plain', 'utf-8')
    msg['Subject'] = subject
    msg['From'] = os.getenv('EMAIL_ADDRESS')
    msg['To'] = to_email

    try:
        with smtplib.SMTP(os.getenv('EMAIL_HOST'), int(os.getenv('EMAIL_PORT'))) as server:
            server.starttls()
            server.login(os.getenv('EMAIL_ADDRESS'), os.getenv('EMAIL_PASSWORD'))
            server.send_message(msg)
            print("[EMAIL] Звіт успішно відправлено.")
    except Exception as e:
        print(f"[EMAIL ERROR] Не вдалося надіслати лист: {str(e)}")

@app.route('/authenticate', methods=['POST'])
def authenticate():
    seller_name = request.json.get("seller_name", "").strip()
    selected_category = request.json.get("category", "")
    if not seller_name:
        return jsonify({"error": "Будь ласка, введіть ваше ПІБ"}), 400

    session['seller_name'] = seller_name
    session['category'] = selected_category
    session.modified = True
    return jsonify({"success": True, "message": f"Вітаємо, {seller_name}!"})

def get_situation_from_session():
    # Отримуємо стиснуту ситуацію з сесії
    compressed_situation_base64 = session.get('compressed_situation', '')
    if compressed_situation_base64:
        # Розкодовуємо з base64
        compressed_situation = base64.b64decode(compressed_situation_base64)
        
        # Розпаковуємо дані
        decompressed_data_bytes = zlib.decompress(compressed_situation)
        decompressed_data_str = decompressed_data_bytes.decode('utf-8')
        
        # Заміна eval на JSON
        try:
            situation = json.loads(decompressed_data_str)  # Безпечніше розбирати через JSON
            return situation
        except ValueError as e:
            print(f"Помилка при розборі даних: {e}")
            return None
    return None

@app.errorhandler(500)
def internal_error(error):
    if 'seller_name' in session:
        generate_report(session)  # Зберегти звіт навіть при помилці
    return jsonify({"error": "Внутрішня помилка сервера"}), 500

def init_conversation():
    saved_category = session.get('category', 'exam')  # зберігаємо до очистки
    session.clear()  # чистимо сесію
    session['category'] = saved_category  # відновлюємо категорію

    # отримуємо список ID по категорії
    category = session.get('category', 'exam')
    allowed_ids = CATEGORY_SITUATION_IDS.get(category, list(range(1, 37)))
    filtered_situations = [s for s in SITUATIONS if s['id'] in allowed_ids]
    selected_situation = random.choice(filtered_situations)

    # debug print після обчислень
    print("[DEBUG] Обрана категорія:", category)
    print("[DEBUG] Доступні ID:", [s["id"] for s in filtered_situations])

    session['situation'] = selected_situation
    session['current_situation_id'] = selected_situation["id"]

    session['voice'] = assign_voice_for_situation(selected_situation["id"])
    print("[DEBUG] Голос для цієї ситуації:", session['voice'])
    
    # Компресуємо дані ситуації
    situation_str = str(selected_situation)  # Перетворюємо в рядок
    situation_bytes = situation_str.encode('utf-8')  # Перетворюємо в байти
    compressed_situation = zlib.compress(situation_bytes)  # Стискаємо
    compressed_situation_base64 = base64.b64encode(compressed_situation).decode('utf-8')  # Кодуємо в base64
    session['compressed_situation'] = compressed_situation_base64  # Зберігаємо в сесії

    # Зберігаємо інші дані сесії
    session['current_situation_id'] = selected_situation["id"]
    for cat, ids in CATEGORY_SITUATION_IDS.items():
        if selected_situation["id"] in ids:
            session["current_category"] = cat
            break
    session['available_models'] = TOOL_MODELS.copy()  # Використовуємо копію, щоб уникнути модифікації оригіналу
    session['stage'] = 1
    session['chat_active'] = True
    session['message_count'] = 0
    session['wrong_model_attempts'] = 0
    session['question_count'] = 0
    session['unique_questions'] = []
    session['off_topic_count'] = 0
    session['misunderstood_count'] = 0
    session['objection_round'] = 1
    session['warning_count'] = 0
    session['user_answers'] = {}
    session['question_scores'] = []
    session['model_score'] = 0
    session['total_score'] = 0
    session['seller_replies'] = []
    session['irrelevant_answers'] = 0
    session.modified = True

    system_prompt = f"""
    Ти — віртуальний **клієнт магазину**, який **прийшов купити інструмент**.

    🔹 **Головна мета** — триматися ролі покупця, який висловлює свої вимоги та уточнює деталі щодо інструменту.  
    🔹 **Формат відповіді** — завжди одне коротке речення (5–15 слів).  
    🔹 **Тон** — природний діалог покупця: можеш бути трохи нетерплячим, прискіпливим, але без зайвої ввічливості.

    ---

    ### **Правила поведінки** (у порядку пріоритету)
    1. **Ніколи не грай роль продавця** — не консультуй, не пропонуй моделі, не став зустрічних запитань.
    2. **Відповідай тільки на те, що сказав продавець (користувач)**. Не починай нових тем.
    3. Якщо репліка користувача **стосується інструменту або вимог до нього** — можеш надихатися підказками (але перефразовуй їх і використовуй максимум одну на відповідь).
    4. Якщо репліка користувача **не стосується інструменту** — відповідай коротко та нейтрально без підказок.  
    Приклади: "Мене це не цікавить", "Давайте про інструмент", "Не хочу про це говорити".
    5. Якщо користувач використовує **лайку або образливі слова** — натякни, що можеш піти, бо хочеш належного обслуговування.  
    Приклади: "Не спілкуйтеся так зі мною", "Ще трохи й я піду".
    6. Не розвивай тему самостійно, навіть якщо користувач робить паузи або пише загальні фрази.

    ---

    ### **Ситуація**:
    {selected_situation['description']}

    ### **Мої потреби**:
    {selected_situation['requirements']}

    ### **Моя поведінка**:
    {selected_situation.get('behavior')}

    ---

    ### **Підказки (використовуй лише при розмові про інструмент)**:
    {'\n'.join(selected_situation.get("hints", []))}

    ---

    ### **Початок розмови**:
    "Добрий день, мені треба інструмент."
    """
    return [
        {"role": "system", "content": system_prompt},
        {"role": "assistant", "content": f"Добрий день, мені треба {session['situation']['description']}"}
    ]
def evaluate_question(question, situation_description):
    prompt = f"""
Ти — клієнт, який обирає інструмент в магазині електроінструментів. Оціни питання за критеріями:

Ситуація: "{situation_description}"
Питання: "{question}"

Критерії оцінки (відповідь лише цифрою):
2 - якщо питання чітко стосується вибору інструменту **(технічні параметри, будова, сфера застосування, сумісність, застосування)**
1 - якщо питання частково стосується теми роботи інструменту, характеристик тощо
0 - якщо питання не стосується вибору інструменту (соціальне, про компанію тощо)

**Важливо: це мають бути питання коректні, без матюків та слів, що стосуються грошей, матеріалього становища.**

Відповідь має бути лише однією цифрою (0, 1 або 2) без жодних додаткових слів.
"""
    
    try:
        response = client.chat.completions.create(
            model="gpt-3.5-turbo",
            messages=[{"role": "user", "content": prompt}],
            temperature=0,
            max_tokens=2,
        )
        score = response.choices[0].message.content.strip()
        if score.isdigit():
            return min(max(int(score), 0), 2)
        return 0
    except Exception as e:
        print(f"Помилка при оцінці питання: {str(e)}")
        return 0

def match_model(user_input, available_models):
    user_model = re.sub(r'[^A-Z0-9-]', '', user_input.upper())
    matched_models = [m for m in available_models if user_model in m.upper()]
    
    if not matched_models:
        return None  # Модель не знайдена
    
    return matched_models[0]

@app.route('/')
def home():
    if "unique_questions" not in session:
        session["unique_questions"] = []
    return render_template('index.html')

@app.route('/start_chat')
def start_chat():
    session['history'] = init_conversation()
    # Якщо треба, скинь інші параметри
    session["stage"] = 1
    session["question_count"] = 0
    session["model"] = None
    session["chat_active"] = True
    session["unique_questions"] = []

    return jsonify({
        "reply": session['history'][1]['content'],
        "avatar": session["situation"].get("avatar", "clientpes.png")
    })

@app.route("/restart-chat", methods=["POST"])
def restart_chat():
    keys_to_clear = [
        "history", "stage", "question_count", "model", "chat_active",
        "unique_questions", "misunderstood_count", "available_models",
        "wrong_model_attempts", "user_answers", "off_topic_count",
        "objection_round", "generated_questions", "current_question_index",
        "current_situation_id", "situation", "last_seller_reply",
        "current_objection", "hint_shown", "question_scores", "model_score", "total_score", "seller_replies"
    ]
    for key in keys_to_clear:
        session.pop(key, None)
    return jsonify({"message": "Сесію скинуто."})

@app.route("/show_models", methods=["POST"])
def show_models():
    # Отримуємо поточну ситуацію
    current_situation = session.get("situation")
    
    # Отримуємо правильні і неправильні моделі з поточної ситуації
    correct_models = current_situation["correct_models"]
    wrong_models = current_situation["wrong_models"]
    
    # Фільтруємо доступні моделі на основі ситуації
    available_models = correct_models + wrong_models

    session["stage"] = 2  # Переконуємось, що ми на правильному етапі для вибору моделі

    return jsonify({
        "models": available_models,
        "stage": 2
    })

def generate_report(session_data):
    seller_name = session_data.get('seller_name') or 'Невідомий продавець'
    total_score = session_data.get('total_score', 0)
    max_score = 40
    selected_category = session_data.get('category', 'Не вказано')
    
    report_lines = [
        f"Звіт про діалог продавця: {seller_name}",
        f"Дата: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}",
        f"Обрана категорія: {selected_category}",
        f"Оцінка: {total_score}/{max_score}",
        "\nДіалог:",
    ]
    
    # Додати всі репліки діалогу
    for message in session_data.get('conversation_log', []):
        if message['role'] == 'user':
            role = "Продавець"
        elif message['role'] == 'assistant':
            role = "Клієнт (бот)"
        else:
            role = message['role'].capitalize()
        report_lines.append(f"{role} ({message['timestamp']}): {message['message']}")
    
    # Додати результати оцінювання
    report_lines.extend([
        "\nРезультати:",
        f"- Оцінка за модель: {session_data.get('model_score', 0)}/4",
        f"- Оцінка за питання: {sum(q['score'] for q in session_data.get('question_scores', []))}/10",
        f"- Оцінка за відповіді: {sum(a['score'] for a in session_data.get('user_answers', {}).values())}/6",
        f"- Оцінка за заперечення: {session_data.get('objection_score', 0)}/10"
    ])
    
    return "\n".join(report_lines)

@app.after_request
def allow_iframe(response):
    response.headers['X-Frame-Options'] = 'https://ako.dnipro-m.ua/'
    return response

@app.route("/chat", methods=["POST"])
def chat():
    print("Доступні моделі для вибору:", session.get("available_models"))
    user_input = request.json.get("message", "").strip()

    print(f"[DEBUG] Користувач написав: {user_input}")
    print(f"[DEBUG] Поточна стадія: {session.get('stage')}")

    # Ініціалізація змінних сесії
    session.setdefault("misunderstood_count", 0)
    session.setdefault("objection_round", 1)
    session.setdefault("question_scores", [])
    session.setdefault("user_answers", {})
    session.setdefault("seller_replies", [])

    if 'conversation_log' not in session:
        session['conversation_log'] = []
    
    if 'seller_name' not in session:
        seller_name = request.json.get("seller_name")
        if seller_name:
            session['seller_name'] = seller_name

    # Використовуємо setdefault для conversation_log, щоб уникнути помилок KeyError
    session.setdefault('conversation_log', [])

    if "history" not in session or not session["history"]:
        session["history"] = init_conversation()
        session["stage"] = 1
        session["question_count"] = 0
        session["model"] = None
        session["chat_active"] = True
        session["unique_questions"] = []
        session["misunderstood_count"] = 0
        session["wrong_model_attempts"] = 0
        session["model_score"] = 0
        session["total_score"] = 0
        session["objection_round"] = 1

        # --- Stage 1: Питання клієнта ---
    if session["stage"] == 1:

        # --- Перевірка, чи користувач вибрав модель ---
        if user_input.lower().startswith("обираю модель:"):
            model_name = user_input.split(":", 1)[1].strip()
            session["stage"] = 2
            return jsonify({
                "reply": f"Ви обрали модель: {model_name}. Переходимо до перевірки...",
                "chat_ended": False,
                "stage": 2,
                "chosen_model": model_name
            })

        # --- Далі йде твоя логіка оцінки питання ---
        question_score = evaluate_question(user_input, session["situation"]["description"])
        
        # Перевірка на дублікати
        is_duplicate = user_input.lower() in [q.lower() for q in session["unique_questions"]]
        if is_duplicate:
            question_score = max(0, question_score - 1)
            print(f"[SCORE] Повторне питання: оцінка знижена до {question_score} балів")
        
        print(f"[SCORE] Оцінка питання: {question_score} бал(и) | Поточний рахунок: {session.get('total_score', 0)}")
        
        session["question_scores"].append({
            "question": user_input,
            "score": question_score
        })
        
        session["question_count"] += 1
        
        if question_score == 0:
            session["misunderstood_count"] += 1
        
        if not is_duplicate and question_score > 0:
            session["unique_questions"].append(user_input)
        
        # Бонус
        perfect_questions = sum(1 for q in session["question_scores"] if q["score"] == 2)
        if perfect_questions >= 3 and "bonus_added" not in session:
            session["total_score"] = min(session.get("total_score", 0) + 2, 10)
            session["bonus_added"] = True
            print(f"[SCORE] Бонус +2 бали за 3 коректних запитання")
        
        if session["misunderstood_count"] >= 3:
            session["chat_active"] = False
            report_content = generate_report(session)
            send_email_report(
                subject=f"Звіт про діалог — {session.get('seller_name', 'Продавець')}",
                body=report_content,
                to_email="voloshchenko2014@gmail.com"
            )
            return jsonify({
                "reply": "Ви поставили декілька некоректних питань. Діалог завершено.",
                "chat_ended": True,
                "show_restart_button": True
            })
        
        if question_score == 0:
            return jsonify({
                "reply": "Ваше питання не стосується вибору інструменту. Спробуйте інше питання.",
                "chat_ended": False,
                "question_progress": session["question_count"]
            })
        
        current_questions_score = sum(q["score"] for q in session["question_scores"])
        current_questions_score = min(current_questions_score, 10)
        print(f"[SCORE] Загальний бал за питання: {current_questions_score}/10")
        
        session["history"].append({"role": "user", "content": user_input})
        session['conversation_log'].append({
            'role': 'user',
            'message': user_input,
            'timestamp': datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        })

        try:
            response = client.chat.completions.create(
                model="gpt-3.5-turbo",
                messages=session["history"][-20:],
                temperature=0.5,
                max_tokens=150
            )
            answer = response.choices[0].message.content.strip()

            session["history"].append({"role": "assistant", "content": answer})
            session['conversation_log'].append({
                'role': 'assistant',
                'message': answer,
                'timestamp': datetime.now().strftime("%Y-%m-%d %H:%M:%S")
            })

            return jsonify({
                "reply": answer,
                "chat_ended": False,
                "stage": 1,
                "question_progress": session["question_count"],
                "show_model_button": session["question_count"] >= 1
            })
        except Exception as e:
            return jsonify({
                "reply": "Вибачте, сталася помилка при відповіді. Спробуйте ще раз.",
                "chat_ended": False
            })

    # --- Stage 2: Вибір моделі ---
    elif session["stage"] == 2:
        user_model = re.sub(r'[^A-Z0-9-]', '', user_input.upper())
        matched_models = [m for m in session["available_models"] if user_model in m.upper()]

        if not matched_models:
            session["model_score"] = 0
            session["wrong_model_attempts"] += 1
            session["stage"] = 3
            return jsonify({
                "reply": "Ця модель не підходить для моїх потреб. Давайте продовжимо.",
                "chat_ended": False,
                "stage": 3,
                "model_chosen": False
            })

        user_model = matched_models[0].upper()
        current_situation = next((s for s in SITUATIONS if s["id"] == session.get("current_situation_id")), None)
        if not current_situation:
            return jsonify({
                "reply": "Помилка: ситуація не знайдена.",
                "chat_ended": True,
                "show_restart_button": True
            })

        correct_models = [model.upper() for model in current_situation["correct_models"]]

        # Оцінка моделі
        if user_model in correct_models:
            session["model_score"] = 10  # Максимум 10 балів за правильний вибір
            print(f"[SCORE] Правильна модель: +10 балів")
        else:
            session["model_score"] = 0
            print(f"[SCORE] Неправильна модель: 0 балів")

            # Оновлений вивід для переходу на stage 3
            print(f"[SCORE] Поточний бал за модель: {session['model_score']}/4")
            print(f"[SCORE] Загальний бал: {session.get('total_score', 0) + session['model_score']}")

        # Переходь на stage 3 після оцінки моделі
        session["model"] = user_model
        session["stage"] = 3
        session["current_question_index"] = 0
        session["user_answers"] = {}

        # Генерація уточнюючих питань
        prompt = f"""Ти клієнт, який обрав інструмент {user_model} для {session['situation']['description']}.\n
        Згенеруй 5 питань про **характеристики**, **зовнішню будову**, **функції цього інструменту** , рекомендації по роботі та додаткові витратні матеріали до інструменту. Питання має бути в одне речення."""

        try:
            response = client.chat.completions.create(
                model="gpt-3.5-turbo",
                messages=[
                    {"role": "system", "content": "Ти — клієнт, який має задати уточнюючі запитання про модель інструмента."},
                    {"role": "user", "content": prompt}
                ],
                temperature=0.6,
                max_tokens=150
            )
            content = response.choices[0].message.content or ""
            questions = [line.strip(" 1234567890.-") for line in content.split('\n') if line.strip()]
            session["generated_questions"] = questions
            
            session["history"].append({"role": "user", "content": user_input})
            first_question = questions[0] if questions else "Яке перше ваше питання про цю модель?"
            session["history"].append({"role": "assistant", "content": first_question})

            session['conversation_log'].append({
                'role': 'user',
                'message': user_input,
                'timestamp': datetime.now().strftime("%Y-%m-%d %H:%M:%S")
            })
            session['conversation_log'].append({
                'role': 'assistant',
                'message': f"Добре, {user_model} виглядає непогано. А таке питання:\n\n{first_question}",
                'timestamp': datetime.now().strftime("%Y-%m-%d %H:%M:%S")
            })

            session.modified = True

            return jsonify({
                "reply": f"Добре, {user_model} виглядає непогано. А таке питання:\n\n{first_question}",
                "chat_ended": False,
                "stage": 3
            })
        except Exception as e:
            return jsonify({
                "reply": "Вибачте, сталася помилка при генерації питань. Спробуйте ще раз.",
                "chat_ended": False
            })

    # --- Stage 3: Уточнюючі питання ---
    elif session["stage"] == 3:
        if 'generated_questions' not in session:
            return jsonify({
                "reply": "Питання не знайдені. Давайте почнемо спочатку.",
                "chat_ended": True,
                "show_restart_button": True
            })

        index = session.get('current_question_index', 0)
        current_question = session['generated_questions'][index]

        session["history"].append({"role": "user", "content": user_input})

        session['conversation_log'].append({
            'role': 'user',
            'message': user_input,
            'timestamp': datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        })

        # Оцінка відповіді
        gpt_prompt = f"""
Оціни відповідь користувача на питання.
Питання: "{current_question}"
Відповідь: "{user_input}"

Оціни відповідь продавця за цією шкалою:

2 — відповідь містить **характеристику** і перевагу: що вона означає або як допомагає клієнту у задачі
1 — відповідь містить **лише характеристику** без жодного пояснення, без жодного коментаря
0 — відповідь **не по темі** або **занадто загальна**

Відповідай лише цифрою: 0, 1 або 2.
"""
        try:
            evaluation = client.chat.completions.create(
                model="gpt-3.5-turbo",
                messages=[
                    {"role": "system", "content": "Ти оцінюєш відповідь на запитання. Відповідай лише числом: 0, 1 або 2."},
                    {"role": "user", "content": gpt_prompt}
                ],
                temperature=0,
                max_tokens=10
            )
            score_text = evaluation.choices[0].message.content.strip()
            try:
                score = int(score_text)
            except ValueError:
                score = 0
            print(f"[SCORE] Відповідь на питання {session['current_question_index']+1}: {score}/2 балів")

            # Зберігаємо відповідь
            session["user_answers"][current_question] = {
                "answer": user_input,
                "score": score
            }

            # 🔴 Лічильник двох поспіль нерелевантних відповідей
            if score == 0:
                session['irrelevant_answers'] = session.get('irrelevant_answers', 0) + 1
            else:
                session['irrelevant_answers'] = 0  # скидаємо лічильник при нормальній відповіді

            if session['irrelevant_answers'] >= 2:
                session['chat_active'] = False
                report_content = generate_report(session)  # Зберегти звіт навіть при помилці
                send_email_report(
                    subject=f"Звіт про діалог — {session.get('seller_name', 'Продавець')}",
                    body=report_content,
                    to_email="voloshchenko2014@gmail.com"
                )
                return jsonify({
                    "reply": "Вибачте, я не отримав потрібної інформації. Я, мабуть, піду в інший магазин.",
                    "chat_ended": True,
                    "show_restart_button": True
                })

            # Продовжуємо діалог
            raw_score = sum(a["score"] for a in session["user_answers"].values())
            max_answers_score = len(session["generated_questions"]) * 2
            current_answers_score = min(raw_score, max_answers_score)
            print(f"[SCORE] Загальний бал за відповіді: {current_answers_score}/{max_answers_score}")

            session['current_question_index'] += 1

            # Перехід до наступного питання
            if session['current_question_index'] < len(session['generated_questions']):
                next_question = session['generated_questions'][session['current_question_index']]
                session["history"].append({"role": "assistant", "content": next_question})
                session.modified = True

                session['conversation_log'].append({
                    'role': 'assistant',
                    'message': next_question,
                    'timestamp': datetime.now().strftime("%Y-%m-%d %H:%M:%S")
                })

                return jsonify({
                    "reply": next_question,
                    "chat_ended": False
                })
            else:
                # Перехід до Stage 4 (заперечення)
                session["stage"] = 4
                answers_score = sum(a["score"] for a in session["user_answers"].values())

                if answers_score >= 5:
                    feedback = "Гарний інструмент."
                elif answers_score >= 3:
                    feedback = "Інструмент непоганий."
                else:
                    feedback = "Зрозуміло."

                category = session.get("current_category", "default")
                objections = CATEGORY_OBJECTIONS.get(category, CATEGORY_OBJECTIONS["default"])
                session["current_objection"] = random.choice(objections)
                session["objection_round"] = 1

                final_reply = f"{feedback}\n\nХм... {session['current_objection']}"
                session["history"].append({"role": "assistant", "content": final_reply})
                session.modified = True

                return jsonify({
                    "reply": f"{feedback}\n\nХм... {session['current_objection']}",
                    "chat_ended": False,
                    "stage": 4
                })
        except Exception as e:
            return jsonify({
                "reply": "Виникла помилка при оцінюванні відповіді. Спробуйте ще раз.",
                "chat_ended": False
            })

    # --- Stage 4: Обробка заперечень ---
    elif session["stage"] == 4:
        objection = session.get("current_objection", "Заперечення")
        seller_reply = user_input
        session["seller_replies"].append(seller_reply)
        current_round = session.get("objection_round", 1)

        # Додаємо репліку продавця до логу ТІЛЬКИ ОДИН РАЗ
        session['conversation_log'].append({
            'role': 'user',
            'message': seller_reply,
            'timestamp': datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        })

        if current_round <= 2:
            try:
                history = "\n".join([f"Раунд {i+1}: {reply}" for i, reply in enumerate(session["seller_replies"])])
                gpt_prompt = f"""
    Ти — клієнт, який має заперечення: "{objection}".

    Ось як продавець відповідав до цього моменту:
    {history}

    Відповідай як реалістичний клієнт. Реагуй природно на останню репліку продавця: "{seller_reply}".
    Підтримуй контекст заперечення. Твоя відповідь повинна складатися рівно з одного речення (5–15 слів). Не повторюйся."""
                
                response = client.chat.completions.create(
                    model="gpt-3.5-turbo",
                    messages=[
                        {"role": "system", "content": "Ти — клієнт у діалозі з продавцем. Відповідай чесно, логічно і згідно з контекстом заперечення. Твоя відповідь повинна складатися рівно з одного речення (5–15 слів). Не повторюйся."},
                        {"role": "user", "content": gpt_prompt}
                    ],
                    temperature=0.6,
                    max_tokens=50
                )
                reply = response.choices[0].message.content
                session["objection_round"] += 1
                session.modified = True

                # ВИДАЛИТИ цей блок - репліка вже додана вище
                # session['conversation_log'].append({
                #     'role': 'user',
                #     'message': seller_reply,
                #     'timestamp': datetime.now().strftime("%Y-%m-%d %H:%M:%S")
                # })

                # Додаємо відповідь клієнта (GPT)
                session['conversation_log'].append({
                    'role': 'assistant',
                    'message': reply,
                    'timestamp': datetime.now().strftime("%Y-%m-%d %H:%M:%S")
                })

                return jsonify({
                    "reply": reply,
                    "chat_ended": False,
                    "current_round": session["objection_round"]
                })
            except Exception as e:
                return jsonify({
                    "reply": "Вибачте, сталася помилка під час відповіді. Спробуйте ще раз.",
                    "chat_ended": False
                })

        elif current_round == 3:
            try:
                if not session.get("seller_replies"):
                    return jsonify({
                        "reply": "Помилка: відсутні відповіді для оцінювання.",
                        "chat_ended": True,
                        "show_restart_button": True
                    })

                full_history = "\n".join([f"Раунд {i+1}: {reply}" for i, reply in enumerate(session["seller_replies"])])
                evaluation_prompt = f"""
    Ти — експерт з продажів, який оцінює відповіді продавця на заперечення клієнта.

    Заперечення клієнта: "{objection}"

    Ось відповіді продавця (по раундах):
    {full_history}

    Проаналізуй відповіді продавця за 4 критеріями:
    1. Чіткість аргументів
    2. Відповідність запереченню
    3. Наявність доказів, прикладів або логіки
    4. Логічна послідовність і побудова

    Аргумент — це чітке пояснення з доказом, прикладом або логікою, яке прямо стосується заперечення.

    🔻 Оціни рівень переконливості за шкалою:
    - "переконливо" — якщо **аргументи є чіткими та логічними** 
    - "частково переконливо" — якщо **аргументи слабкі, але відповідають на запит** 
    - "непереконливо" — якщо **немає** жодного аргументу або відповідь не по темі

    Відповідай одним словом: "переконливо", "частково переконливо" або "непереконливо". Не додавай пояснень.
    """
                response = client.chat.completions.create(
                    model="gpt-3.5-turbo",
                    messages=[
                        {"role": "system", "content": "Ти — експерт з оцінки комунікацій. Будь об'єктивним."},
                        {"role": "user", "content": evaluation_prompt}
                    ],
                    temperature=0.3,
                    max_tokens=50
                )
                raw_rating = response.choices[0].message.content.strip().lower()

                # Витягнути перше зі слів: переконливо, частково переконливо, непереконливо
                match = re.search(r"(переконливо|частково переконливо|непереконливо)", raw_rating)
                rating = match.group(1) if match else "непереконливо"
                
                if rating == "переконливо":
                    objection_score = 10
                    reply = "Клієнта проконсультовано."
                elif rating == "частково переконливо":
                    objection_score = 5
                    reply = "Клієнта проконсультовано."
                elif rating == "непереконливо":
                    objection_score = 0
                    reply = "Клієнт незадоволений консультацією."
                else:
                    objection_score = 0
                    reply = "Клієнт незадоволений консультацією."  # fallback

                session['objection_score'] = objection_score

                print(f"[SCORE] Оцінка аргументів: {rating} ({objection_score}/5 балів)")

                # Додаємо фінальну відповідь системи
                session['conversation_log'].append({
                    'role': 'assistant',
                    'message': reply,
                    'timestamp': datetime.now().strftime("%Y-%m-%d %H:%M:%S")
                })

                model_score = session.get("model_score", 0)
                questions_score = sum(q["score"] for q in session.get("question_scores", []))
                answers_score = sum(a["score"] for a in session.get("user_answers", {}).values())
                objection_score = session.get('objection_score', 0)
                total_score = model_score + questions_score + answers_score + objection_score
                max_score = 10 + 10 + 10 + 10

                print("\n=== ФІНАЛЬНИЙ РАХУНОК ===")
                print(f"[SCORE] За модель: {model_score}/10")
                print(f"[SCORE] За питання: {questions_score}/10")
                print(f"[SCORE] За відповіді: {answers_score}/10")
                print(f"[SCORE] За заперечення: {objection_score}/10")
                print(f"[SCORE] ЗАГАЛЬНИЙ БАЛ: {total_score}/40")

                if total_score >= 32:
                    summary_label = "🟢 Чудова консультація."
                elif total_score >= 24:
                    summary_label = "🟡 Задовільна консультація."
                else:
                    summary_label = "🔴 Незадовільна консультація."

                full_reply = f"{reply}\n\n📊 Результат: {summary_label}"

                # Збереження звіту
                session["total_score"] = total_score
                report_content = generate_report(dict(session))
                report_filename = f"report_{session.get('seller_name', 'unknown')}_{datetime.now().strftime('%Y%m%d_%H%M%S')}.txt"
                
                os.makedirs('reports', exist_ok=True)
                
                send_email_report(
                    subject=f"Звіт про діалог — {session.get('seller_name', 'Продавець')}",
                    body=report_content,
                    to_email="voloshchenko2014@gmail.com"
                )

                session.clear()
                session.modified = True

                return jsonify({
                    "reply": f"{full_reply}\n\nЗвіт збережено для вашого тренера.",
                    "chat_ended": True,
                    "show_restart_button": True,
                    "report_filename": report_filename
                })
            
            except Exception as e:
                print(f"Помилка при оцінюванні: {str(e)}")
                return jsonify({
                    "reply": "Вибачте, не вдалося обробити відповідь. Давайте спробуємо ще раз?",
                    "chat_ended": False
                })

    return jsonify({
        "reply": "Виникла непередбачена помилка. Спробуйте ще раз.",
        "chat_ended": True,
        "show_restart_button": True
    })

@app.route("/speech-to-text", methods=["POST"])
def speech_to_text():
    if "file" not in request.files:
        return jsonify({"error": "Файл не надісланий"}), 400

    audio_file = request.files["file"]

    try:
        # зберігаємо як webm
        with tempfile.NamedTemporaryFile(delete=False, suffix=".webm") as tmp:
            audio_file.save(tmp.name)
            with open(tmp.name, "rb") as f:
                transcript = client.audio.transcriptions.create(
                    model="gpt-4o-mini-transcribe",
                    file=f
                )
        os.unlink(tmp.name)

        text = transcript.text.strip()
        return jsonify({"text": text})
    except Exception as e:
        print(f"[STT ERROR] {str(e)}")
        return jsonify({"error": "Помилка розпізнавання"}), 500
    
def assign_voice_for_situation(situation_id):
    """Визначаємо голос для ситуації один раз"""
    if situation_id in FEMALE_IDS:
        return random.choice(FEMALE_VOICES)
    else:
        return random.choice(MALE_VOICES)

@app.route("/speak", methods=["POST"])
def speak():
    text = request.json.get("text", "").strip()
    if not text:
        return jsonify({"error": "Порожній текст"}), 400
    
    category = session.get("category", None)
    if category != "exam":   # ← тут вкажи категорію, де озвучка дозволена
        return jsonify({"error": "Озвучка недоступна для цієї категорії"}), 403

    # Використовуємо вже визначений голос
    voice = session.get("voice", "alloy")

    try:
        response = client.audio.speech.create(
            model="gpt-4o-mini-tts",
            voice=voice,
            input=text
        )
        with tempfile.NamedTemporaryFile(delete=False, suffix=".mp3") as tmp:
            tmp.write(response.read())
            tmp_path = tmp.name
        with open(tmp_path, "rb") as f:
            audio_data = f.read()
        os.unlink(tmp_path)
        return audio_data, 200, {
            "Content-Type": "audio/mpeg",
            "Content-Disposition": f"inline; filename={voice}.mp3"
        }
    except Exception as e:
        print(f"[TTS ERROR] {str(e)}")
        return jsonify({"error": "Помилка генерації аудіо"}), 500
    
if __name__ == '__main__':
    app.run(host='0.0.0.0', port=5000, debug=True)